"use strict";(self.webpackChunkjavascript_parser_in_rust=self.webpackChunkjavascript_parser_in_rust||[]).push([[392],{73:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=t(2676),r=t(5241);const i={id:"ast",title:"Abstract Syntax Tree"},a=void 0,o={id:"ast",title:"Abstract Syntax Tree",description:"The parser in the upcoming chapter is responsible for turning Tokens into an abstract syntax tree (AST).",source:"@site/docs/ast.md",sourceDirName:".",slug:"/ast",permalink:"/javascript-parser-in-rust/docs/ast",draft:!1,unlisted:!1,editUrl:"https://github.com/oxc-project/javascript-parser-in-rust/tree/main/docs/ast.md",tags:[],version:"current",frontMatter:{id:"ast",title:"Abstract Syntax Tree"},sidebar:"tutorialSidebar",previous:{title:"Lexer",permalink:"/javascript-parser-in-rust/docs/lexer"},next:{title:"Parser",permalink:"/javascript-parser-in-rust/docs/parser"}},l={},c=[{value:"Getting familiar with the AST",id:"getting-familiar-with-the-ast",level:2},{value:"estree",id:"estree",level:2},{value:"Rust Optimizations",id:"rust-optimizations",level:2},{value:"Memory Allocations",id:"memory-allocations",level:3},{value:"Enum Size",id:"enum-size",level:3},{value:"Memory Arena",id:"memory-arena",level:4},{value:"JSON Serialization",id:"json-serialization",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"The parser in the upcoming chapter is responsible for turning Tokens into an abstract syntax tree (AST).\nIt is much nicer to work on the AST compared to the source text."}),"\n",(0,s.jsx)(n.p,{children:"All JavaScript toolings work on the AST level, for example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A linter (e.g. eslint) checks the AST for errors"}),"\n",(0,s.jsx)(n.li,{children:"A formatter (e.g.prettier) prints the AST back to JavaScript text"}),"\n",(0,s.jsx)(n.li,{children:"A minifier (e.g. terser) transforms the AST"}),"\n",(0,s.jsx)(n.li,{children:"A bundler connects all import and export statements between ASTs from different files"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In this chapter, let's construct a JavaScript AST by using Rust structs and enums."}),"\n",(0,s.jsx)(n.h2,{id:"getting-familiar-with-the-ast",children:"Getting familiar with the AST"}),"\n",(0,s.jsxs)(n.p,{children:["To get ourselves comfortable with an AST, let's visit ",(0,s.jsx)(n.a,{href:"https://astexplorer.net/",children:"ASTExplorer"})," and see what it looks like.\nOn the top panel, select JavaScript, and then ",(0,s.jsx)(n.code,{children:"acorn"}),", type in ",(0,s.jsx)(n.code,{children:"var a"})," and we will see a tree view and a JSON view."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "type": "Program",\n  "start": 0,\n  "end": 5,\n  "body": [\n    {\n      "type": "VariableDeclaration",\n      "start": 0,\n      "end": 5,\n      "declarations": [\n        {\n          "type": "VariableDeclarator",\n          "start": 4,\n          "end": 5,\n          "id": {\n            "type": "Identifier",\n            "start": 4,\n            "end": 5,\n            "name": "a"\n          },\n          "init": null\n        }\n      ],\n      "kind": "var"\n    }\n  ],\n  "sourceType": "script"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Since this is a tree, every object is a node with a type name (e.g. ",(0,s.jsx)(n.code,{children:"Program"}),", ",(0,s.jsx)(n.code,{children:"VariableDeclaration"}),", ",(0,s.jsx)(n.code,{children:"VariableDeclarator"}),", ",(0,s.jsx)(n.code,{children:"Identifier"}),").\n",(0,s.jsx)(n.code,{children:"start"})," and ",(0,s.jsx)(n.code,{children:"end"})," are the offsets from the source."]}),"\n",(0,s.jsx)(n.h2,{id:"estree",children:"estree"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/estree/estree",children:"estree"})," is a community standard grammar specification for JavaScript,\nit defines ",(0,s.jsx)(n.a,{href:"https://github.com/estree/estree/blob/master/es5.md",children:"all the AST nodes"})," so different tools\ncan be compatible with each other."]}),"\n",(0,s.jsxs)(n.p,{children:["The basic building block for any AST node is the ",(0,s.jsx)(n.code,{children:"Node"})," type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[derive(Debug, Default, Clone, Copy, Serialize, PartialEq, Eq)]\npub struct Node {\n    /// Start offset in source\n    pub start: usize,\n\n    /// End offset in source\n    pub end: usize,\n}\n\nimpl Node {\n    pub fn new(start: usize, end: usize) -> Self {\n        Self { start, end }\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["AST for ",(0,s.jsx)(n.code,{children:"var a"})," is defined as"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct Program {\n    pub node: Node,\n    pub body: Vec<Statement>,\n}\n\npub enum Statement {\n    VariableDeclarationStatement(VariableDeclaration),\n}\n\npub struct VariableDeclaration {\n    pub node: Node,\n    pub declarations: Vec<VariableDeclarator>,\n}\n\npub struct VariableDeclarator {\n    pub node: Node,\n    pub id: BindingIdentifier,\n    pub init: Option<Expression>,\n}\n\npub struct BindingIdentifier {\n    pub node: Node,\n    pub name: String,\n}\n\npub enum Expression {\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Rust does not have inheritance, so ",(0,s.jsx)(n.code,{children:"Node"}),' is added to each struct (this is called "composition over Inheritance").']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Statement"}),"s and ",(0,s.jsx)(n.code,{children:"Expression"}),"s are enums because they will be expanded with a lot of other node types, for example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub enum Expression {\n    AwaitExpression(AwaitExpression),\n    YieldExpression(YieldExpression),\n}\n\npub struct AwaitExpression {\n    pub node: Node,\n    pub expression: Box<Expression>,\n}\n\npub struct YieldExpression {\n    pub node: Node,\n    pub expression: Box<Expression>,\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Box"})," is needed because self-referential structs are not allowed in Rust."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["JavaScript grammar has a lot of nuisances, read the ",(0,s.jsx)(n.a,{href:"/blog/grammar",children:"grammar tutorial"})," for amusement."]})}),"\n",(0,s.jsx)(n.h2,{id:"rust-optimizations",children:"Rust Optimizations"}),"\n",(0,s.jsx)(n.h3,{id:"memory-allocations",children:"Memory Allocations"}),"\n",(0,s.jsxs)(n.p,{children:["Back in the ",(0,s.jsx)(n.a,{href:"/javascript-parser-in-rust/docs/overview",children:"Overview"})," chapter,\nI briefly mentioned that we need to look out for heap-allocated structs such as ",(0,s.jsx)(n.code,{children:"Vec"})," and ",(0,s.jsx)(n.code,{children:"Box"})," because heap allocations are not cheap."]}),"\n",(0,s.jsxs)(n.p,{children:["Take a look at the ",(0,s.jsx)(n.a,{href:"https://github.com/swc-project/swc/blob/main/crates/swc_ecma_ast/src/expr.rs",children:"real world implementation from swc"}),",\nwe can see that an AST can have lots of ",(0,s.jsx)(n.code,{children:"Box"}),"s and ",(0,s.jsx)(n.code,{children:"Vec"}),"s, and also note that the ",(0,s.jsx)(n.code,{children:"Statement"})," and ",(0,s.jsx)(n.code,{children:"Expression"})," enums contain\na dozen of enum variants."]}),"\n",(0,s.jsx)(n.h3,{id:"enum-size",children:"Enum Size"}),"\n",(0,s.jsx)(n.p,{children:"The first optimization we are going to make is to reduce the size of the enums."}),"\n",(0,s.jsx)(n.p,{children:"It is known that the byte size of a Rust enum is the union of all its variants.\nFor example, the following enum will take up 56 bytes (1 byte for the tag, 48 bytes for the payload, and 8 bytes for alignment)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"enum Name {\n    Anonymous, // 0 byte payload\n    Nickname(String), // 24 byte payload\n    FullName{ first: String, last: String }, // 48 byte payload\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["This example is taken from ",(0,s.jsx)(n.a,{href:"https://adeschamps.github.io/enum-size",children:"this blog post"})]})}),"\n",(0,s.jsxs)(n.p,{children:["As for the ",(0,s.jsx)(n.code,{children:"Expression"})," and ",(0,s.jsx)(n.code,{children:"Statement"})," enums, they can take up to more than 200 bytes with our current setup."]}),"\n",(0,s.jsxs)(n.p,{children:["These 200 bytes need to be passed around, or accessed every time we do a ",(0,s.jsx)(n.code,{children:"matches!(expr, Expression::AwaitExpression(_))"})," check,\nwhich is not very cache friendly for performance."]}),"\n",(0,s.jsx)(n.p,{children:"A better approach would be to box the enum variants and only carry 16 bytes around."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub enum Expression {\n    AwaitExpression(Box<AwaitExpression>),\n    YieldExpression(Box<YieldExpression>),\n}\n\npub struct AwaitExpression {\n    pub node: Node,\n    pub expression: Expression,\n}\n\npub struct YieldExpression {\n    pub node: Node,\n    pub expression: Expression,\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To make sure the enums are indeed 16 bytes on 64-bit systems, we can use ",(0,s.jsx)(n.code,{children:"std::mem::size_of"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[test]\nfn no_bloat_enum_sizes() {\n    use std::mem::size_of;\n    assert_eq!(size_of::<Statement>(), 16);\n    assert_eq!(size_of::<Expression>(), 16);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:'"no bloat enum sizes" test cases can often be seen in the Rust compiler source code for ensuring small enum sizes.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"reference",children:"https://github.com/rust-lang/rust/blob/9c20b2a8cc7588decb6de25ac6a7912dcef24d65/compiler/rustc_ast/src/ast.rs#L3033-L3042\n"})}),"\n",(0,s.jsx)(n.p,{children:"To find other large types, we can run"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"RUSTFLAGS=-Zprint-type-sizes cargo +nightly build -p name_of_the_crate --release\n"})}),"\n",(0,s.jsx)(n.p,{children:"and see"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markup",children:"print-type-size type: `ast::js::Statement`: 16 bytes, alignment: 8 bytes\nprint-type-size     discriminant: 8 bytes\nprint-type-size     variant `BlockStatement`: 8 bytes\nprint-type-size         field `.0`: 8 bytes\nprint-type-size     variant `BreakStatement`: 8 bytes\nprint-type-size         field `.0`: 8 bytes\nprint-type-size     variant `ContinueStatement`: 8 bytes\nprint-type-size         field `.0`: 8 bytes\nprint-type-size     variant `DebuggerStatement`: 8 bytes\nprint-type-size         field `.0`: 8 bytes\n"})}),"\n",(0,s.jsx)(n.h4,{id:"memory-arena",children:"Memory Arena"}),"\n",(0,s.jsxs)(n.p,{children:["Using the global memory allocator for the AST is actually not really efficient.\nEvery ",(0,s.jsx)(n.code,{children:"Box"})," and ",(0,s.jsx)(n.code,{children:"Vec"})," are allocated on demand and then dropped separately.\nWhat we would like to do is pre-allocate memory and drop it in wholesale."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://manishearth.github.io/blog/2021/03/15/arenas-in-rust/",children:"This blog post"})," explains memory arena in more detail."]})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://docs.rs/bumpalo/latest/bumpalo/",children:(0,s.jsx)(n.code,{children:"bumpalo"})})," is a very good candidate for our use case, according to its documentation:"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Bump allocation is a fast, but limited approach to allocation.\nWe have a chunk of memory, and we maintain a pointer within that memory. Whenever we allocate an object,\nwe do a quick check that we have enough capacity left in our chunk to allocate the object and then update the pointer by the object\u2019s size. That\u2019s it!"}),"\n",(0,s.jsx)(n.p,{children:"The disadvantage of bump allocation is that there is no general way to deallocate individual objects or reclaim the memory region for a no-longer-in-use object."}),"\n",(0,s.jsx)(n.p,{children:"These trade offs make bump allocation well-suited for phase-oriented allocations. That is, a group of objects that will all be allocated during the same program phase, used, and then can all be deallocated together as a group."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["By using ",(0,s.jsx)(n.code,{children:"bumpalo::collections::Vec"})," and ",(0,s.jsx)(n.code,{children:"bumpalo::boxed::Box"}),", our AST will have lifetimes added to it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use bumpalo::collections::Vec;\nuse bumpalo::boxed::Box;\n\npub enum Expression<'a> {\n    AwaitExpression(Box<'a, AwaitExpression>),\n    YieldExpression(Box<'a, YieldExpression>),\n}\n\npub struct AwaitExpression<'a> {\n    pub node: Node,\n    pub expression: Expression<'a>,\n}\n\npub struct YieldExpression<'a> {\n    pub node: Node,\n    pub expression: Expression<'a>,\n}\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"caution",children:[(0,s.jsx)(n.p,{children:"Please be cautious if we are not comfortable dealing with lifetimes at this stage.\nOur program will work fine without a memory arena."}),(0,s.jsx)(n.p,{children:"Code in the following chapters does not demonstrate the use of a memory arena for simplicity."})]}),"\n",(0,s.jsx)(n.h2,{id:"json-serialization",children:"JSON Serialization"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://serde.rs/",children:"serde"})," can be used serialize the AST to JSON. Some techniques are needed to make it ",(0,s.jsx)(n.code,{children:"estree"})," compatible.\nHere are some examples:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use serde::Serialize;\n\n#[derive(Debug, Clone, Serialize, PartialEq)]\n#[serde(tag = "type")]\n#[cfg_attr(feature = "estree", serde(rename = "Identifier"))]\npub struct IdentifierReference {\n    #[serde(flatten)]\n    pub node: Node,\n    pub name: Atom,\n}\n\n#[derive(Debug, Clone, Serialize, PartialEq, Hash)]\n#[serde(tag = "type")]\n#[cfg_attr(feature = "estree", serde(rename = "Identifier"))]\npub struct BindingIdentifier {\n    #[serde(flatten)]\n    pub node: Node,\n    pub name: Atom,\n}\n\n#[derive(Debug, Serialize, PartialEq)]\n#[serde(untagged)]\npub enum Expression<\'a> {\n    ...\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'serde(tag = "type")'}),' is used to make the struct name a "type" field, i.e. ',(0,s.jsx)(n.code,{children:'{ "type" : "..." }'})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cfg_attr"})," + ",(0,s.jsx)(n.code,{children:"serde(rename)"})," is used to rename different struct names to the same name, since ",(0,s.jsx)(n.code,{children:"estree"})," does not distinguish different identifiers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"serde(untagged)"})," on the enum is used to not create an extra JSON object for the enum"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},5241:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var s=t(5271);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);