"use strict";(self.webpackChunkjavascript_parser_in_rust=self.webpackChunkjavascript_parser_in_rust||[]).push([[377],{8731:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var t=r(2676),s=r(5241);const i={id:"typescript",title:"TypeScript"},a=void 0,o={id:"typescript",title:"TypeScript",description:"So you are done with JavaScript and you want to challenge parsing TypeScript?",source:"@site/docs/typescript.md",sourceDirName:".",slug:"/typescript",permalink:"/javascript-parser-in-rust/docs/typescript",draft:!1,unlisted:!1,editUrl:"https://github.com/oxc-project/javascript-parser-in-rust/tree/main/docs/typescript.md",tags:[],version:"current",frontMatter:{id:"typescript",title:"TypeScript"},sidebar:"tutorialSidebar",previous:{title:"Semantic Analysis",permalink:"/javascript-parser-in-rust/docs/semantics_analysis"},next:{title:"References",permalink:"/javascript-parser-in-rust/docs/references"}},c={},d=[{value:"JSX vs TSX",id:"jsx-vs-tsx",level:2},{value:"Lookahead",id:"lookahead",level:2},{value:"TSIndexSignature",id:"tsindexsignature",level:3},{value:"Arrow Expressions",id:"arrow-expressions",level:3}];function p(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["So you are done with JavaScript and you want to challenge parsing TypeScript?\nThe bad news is that there is no specification,\nbut the good news is that the TypeScript parser is in ",(0,t.jsx)(n.a,{href:"https://github.com/microsoft/TypeScript/blob/main/src/compiler/parser.ts",children:"a single file"})," \ud83d\ude43."]}),"\n",(0,t.jsx)(n.h2,{id:"jsx-vs-tsx",children:"JSX vs TSX"}),"\n",(0,t.jsx)(n.p,{children:"For the following code,"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"let foo = <string> bar;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["It is a syntax error if this is ",(0,t.jsx)(n.code,{children:"tsx"})," (Unterminated JSX),\nbut it is correct ",(0,t.jsx)(n.code,{children:"VariableDeclaration"})," with ",(0,t.jsx)(n.code,{children:"TSTypeAssertion"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"lookahead",children:"Lookahead"}),"\n",(0,t.jsx)(n.p,{children:"In certain places, the parser need to lookahead and peek more than one token to determine the correct grammar."}),"\n",(0,t.jsx)(n.h3,{id:"tsindexsignature",children:"TSIndexSignature"}),"\n",(0,t.jsxs)(n.p,{children:["For example, to parse ",(0,t.jsx)(n.code,{children:"TSIndexSignature"}),", consider the following two cases:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type A = { readonly [a: number]: string }\n           ^__________________________^ TSIndexSignature\n\ntype B = { [a]: string }\n           ^_________^ TSPropertySignature\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For ",(0,t.jsx)(n.code,{children:"type A"})," on the first ",(0,t.jsx)(n.code,{children:"{"}),", we need to peek 5 tokens (",(0,t.jsx)(n.code,{children:"readonly"}),", ",(0,t.jsx)(n.code,{children:"["}),", ",(0,t.jsx)(n.code,{children:"a"}),", ",(0,t.jsx)(n.code,{children:":"})," and ",(0,t.jsx)(n.code,{children:"number"}),") in order to make sure\nit is a ",(0,t.jsx)(n.code,{children:"TSIndexSignature"})," and not a ",(0,t.jsx)(n.code,{children:"TSPropertySignature"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"To make this possible and efficient, the lexer requires a buffer for storing multiple tokens."}),"\n",(0,t.jsx)(n.h3,{id:"arrow-expressions",children:"Arrow Expressions"}),"\n",(0,t.jsxs)(n.p,{children:["Discussed in ",(0,t.jsx)(n.a,{href:"/blog/grammar#cover-grammar",children:"cover grammar"}),",\nwe need to convert from ",(0,t.jsx)(n.code,{children:"Expression"}),"s to ",(0,t.jsx)(n.code,{children:"BindingPattern"}),"s when the ",(0,t.jsx)(n.code,{children:"=>"})," token is found after a SequenceExpression."]}),"\n",(0,t.jsxs)(n.p,{children:["But this approach does not work for TypeScript as each item inside the ",(0,t.jsx)(n.code,{children:"()"})," can have TypeScript syntax, there are just too many cases to cover, for example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"<x>a, b as c, d!;\n(a?: b = {} as c!) => {};\n"})}),"\n",(0,t.jsx)(n.p,{children:"It is recommended to study the TypeScript source code for this specific case. The relevant code are:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function tryParseParenthesizedArrowFunctionExpression(\n  allowReturnTypeInArrowFunction: boolean\n): Expression | undefined {\n  const triState = isParenthesizedArrowFunctionExpression();\n  if (triState === Tristate.False) {\n    // It's definitely not a parenthesized arrow function expression.\n    return undefined;\n  }\n\n  // If we definitely have an arrow function, then we can just parse one, not requiring a\n  // following => or { token. Otherwise, we *might* have an arrow function.  Try to parse\n  // it out, but don't allow any ambiguity, and return 'undefined' if this could be an\n  // expression instead.\n  return triState === Tristate.True\n    ? parseParenthesizedArrowFunctionExpression(\n        /*allowAmbiguity*/ true,\n        /*allowReturnTypeInArrowFunction*/ true\n      )\n    : tryParse(() =>\n        parsePossibleParenthesizedArrowFunctionExpression(\n          allowReturnTypeInArrowFunction\n        )\n      );\n}\n\n//  True        -> We definitely expect a parenthesized arrow function here.\n//  False       -> There *cannot* be a parenthesized arrow function here.\n//  Unknown     -> There *might* be a parenthesized arrow function here.\n//                 Speculatively look ahead to be sure, and rollback if not.\nfunction isParenthesizedArrowFunctionExpression(): Tristate {\n  if (\n    token() === SyntaxKind.OpenParenToken ||\n    token() === SyntaxKind.LessThanToken ||\n    token() === SyntaxKind.AsyncKeyword\n  ) {\n    return lookAhead(isParenthesizedArrowFunctionExpressionWorker);\n  }\n\n  if (token() === SyntaxKind.EqualsGreaterThanToken) {\n    // ERROR RECOVERY TWEAK:\n    // If we see a standalone => try to parse it as an arrow function expression as that's\n    // likely what the user intended to write.\n    return Tristate.True;\n  }\n  // Definitely not a parenthesized arrow function.\n  return Tristate.False;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"In summary, the TypeScript parser uses a combination of lookahead (fast path) and backtracking to parse arrow functions."})]})}function l(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},5241:(e,n,r)=>{r.d(n,{Z:()=>o,a:()=>a});var t=r(5271);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);